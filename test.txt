Scaling API - Design Document

Author: [Your Name]
Date: [Date]
Version: 1.1


---

1. Introduction

This document outlines the challenges faced in scaling the API, the proposed solutions, and the design decisions taken to improve performance, maintainability, and functionality.


---

2. Reported Issues & Solutions

2.1 Inconsistent and Slow Search in Explorer

Issue:

Search functionality in Explorer is inconsistent across the project.

Performance of search operations is slow.


Analysis:

The current search implementation is based on prefix-based searches, which are inefficient for large datasets.

Caching strategies have not been leveraged optimally.


Solution:

1. Short-Term (Interim Solution):

Migrate all search operations to Lucene-based search to improve speed and consistency.

Remove prefix-based searches.



2. Long-Term (Optimized Solution):

Collaborate with the FR team to evaluate the feasibility of Redis caching for improved performance.

Implement Redis-based caching once feasibility is confirmed.




Design Considerations:

Lucene-based search provides indexing and full-text search capabilities.

Redis caching can store frequently accessed search results, reducing database load.



---

2.2 High Turnaround Time for Development & Bug Fixes

Issue:

Slow development cycle for changes and bug fixes.

The initial implementation was a Proof of Concept (POC) that unexpectedly moved to production.


Analysis:

The project has limited resources available for development.

The design lacks core software engineering principles, increasing maintenance effort.


Solution:

1. Resource Optimization:

Reallocate development efforts based on priority tasks.

Evaluate the need for additional developers.



2. Refactoring for Scalability:

Implement SOLID principles to improve maintainability and extensibility.

Apply design patterns such as:

Strategy Pattern for modular and interchangeable implementations.

Open/Closed Principle to allow extending functionality without modifying existing code.





Design Considerations:

Ensures the system is scalable and easy to modify in the future.

Reduces technical debt and makes debugging easier.



---

2.3 Lack of Bidirectional Support Between Systems in Graph Database

Issue:

System A provides data to System B, but System B does not reflect this connection back to System A.

The current implementation relies on SPARQL queries, which only provide one-directional data retrieval.


Analysis:

The project is already using a Stardog Graph Database, but the current SPARQL queries only return one-directional relationships.

There is no mechanism to retrieve reverse links between nodes.


Solution:

1. SPARQL Query Enhancements:

Modify existing queries to support bidirectional data retrieval from Stardog.

Ensure relationships are properly indexed for faster retrieval.



2. Graph Optimization:

Evaluate whether using named graphs or additional predicates in Stardog can improve bidirectional navigation.




Design Considerations:

Ensures accurate representation of system interactions.

Supports better visibility of dependencies.



---

2.4 Need for a Metadata Service for UI Configuration

Issue:

The UI lacks pre-defined knowledge about relationships between nodes.

Relationships should be configurable rather than hardcoded.


Analysis:

Currently, UI depends on the API to determine node relationships dynamically.

This makes it harder to configure and optimize UI interactions.


Solution:

1. Metadata Service:

Introduce a Metadata API that provides static or configurable relationship data to the UI.

This service will define how nodes (systems, persons, entities) are related before any query execution.



2. Predefined Relationship Mapping:

Store relationship metadata in a centralized location, making it configurable.

Ensure UI can fetch this information easily and adjust its behavior accordingly.




Design Considerations:

Improves UI efficiency by reducing dynamic computations.

Allows system relationships to be easily updated without modifying UI logic.



---

2.5 Need for Card-Based Metadata APIs for Nodes

Issue:

Clicking on a node (e.g., system, person) does not provide contextual metadata about that node.


Analysis:

Users expect to see basic information when interacting with nodes (e.g., clicking on a person should display their details).

Currently, there is no structured API to serve this information.


Solution:

1. GraphQL-Based Metadata API:

Implement a GraphQL API to fetch card-based metadata for each node type (systems, persons, etc.).

Ensure flexible querying to fetch required details dynamically.



2. Integration with UI:

Work with the UI team to ensure proper integration of metadata APIs.




Design Considerations:

GraphQL provides flexibility in fetching metadata based on the UI's needs.

Reduces over-fetching or under-fetching of data.

Already discussed with UI team and manager, and the approach has been appreciated.



---

3. Next Steps & Implementation Plan


---

4. Conclusion

This document outlines the reported issues in scaling the API and the structured solutions proposed:

Lucene-based search to improve query performance.

Redis caching for further optimization.

Refactoring with SOLID principles and design patterns to improve maintainability.

Bidirectional support in Graph Database via improved SPARQL queries.

Metadata API for UI Configuration, allowing pre-defined relationships between nodes.

GraphQL-based metadata API for contextual information on nodes.


By implementing these solutions, we aim to enhance system performance, 
